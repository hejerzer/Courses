# Nested tables
Nested tables allows you to create tables of any dimensions, by logic it should result like this:  
```luau
local t = {
  {0, 0, 0},
  {0, 0, 0},
  {0, 0, 0},
}
```
And then you can access any values by using ```t[y][x]``` y being the rows and x the column, this works because t[y] gives the table you wanted and with that same table you're accessing the x index.  
You can always add more tables inside the columns, but for higer dimensions i reccomend using a simple algorith.  

# Getting how many elements does a table has
If you want to know how many values does a table have then you can use the ```#``` keyword before putting the table variable, for example:  
```luau
local t = {3, 1, 2}
print(#t)
print({}) -- empty table
```
Expected output:
```
3
0
```

# Iterating tables inside a "for loop"
You can always iterate between elements of a table and get the index and the position, so you use the function ```pairs```, lets see an example:  
```luau
local t = {
  food = "apple",
  job = "seller",
  age = 21
}

for index, value in pairs(t) do
  print(index, value)
end
```
Expected output:
```
job seller
age 21
food apple
```
In this case, the pairs function gave us 2 variables, index and the value, but as we can see this is not ordered because we are using a dictionary with keys being a string.  
Now these days you're not forced to write the pairs function but you can let Roblox auto-compile the table if you use:  
```luau
for i, v in t do
  print(i, v)
end
```
This has the exact same logic, just the inputs are shuffled.   
This is not as fast as using pairs so i don't reccomend using this.

# Ordinated iteration between arrays
Arrays are usefull because of this, you can iterate tables without the keys being shuffled using the ```ipairs``` function, this one is faster than pairs and only works on arrays, any keys that are not numbers won't be included.  
```luau
local t = {3, 5, 1, 5}

for i, v in ipairs(t) do
  print(i, v)
end
```
Expected output:
```
1 3
2 5
3 1
4 5
```
